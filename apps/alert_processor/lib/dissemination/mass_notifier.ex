defmodule AlertProcessor.Dissemination.MassNotifier do
  @moduledoc "Efficiently saves and enqueues many notifications for sending."

  alias AlertProcessor.SendingQueue
  alias AlertProcessor.Model.{Notification, NotificationSubscription}
  alias AlertProcessor.Repo

  require Logger

  # Save and enqueue notifications in batches equal to (at least) the number of sending workers,
  # so all workers will have something to do while we save the next batch. The test environment
  # sets the number of workers to 0, so we need to ensure the batch size is at least 1.
  @batch_size max(1, Application.fetch_env!(:alert_processor, :notification_workers))

  @doc """
  Saves and enqueues a list of notifications. Always returns `:ok` â€” if any notification fails to
  save, it is skipped and a warning is logged.

  Notifications must be saved prior to enqueueing, as part of the AlertWorker process, otherwise
  the next run of the AlertWorker would mistakenly think some users had not yet been notified and
  enqueue duplicate notifications for them.
  """
  @spec save_and_enqueue([Notification.t()]) :: :ok
  def save_and_enqueue(notifications) do
    notifications
    |> Enum.sort(&mode_sort/2)
    |> Stream.chunk_every(@batch_size)
    |> Enum.each(&save_and_enqueue_batch/1)

    :ok
  end

  # Notifications with a phone number (i.e. SMS messages) should be queued ahead of those without.
  # The logic is inverted here because that causes the existing order to be otherwise preserved.
  defp mode_sort(%{phone_number: nil}, %{phone_number: phone}) when not is_nil(phone), do: false
  defp mode_sort(_, _), do: true

  defp save_and_enqueue_batch(notifications) do
    commit_start = now()
    saved_notifications = save_batch(notifications)
    log("event=commit time=#{now() - commit_start}")

    enqueue_start = now()
    SendingQueue.push_list(saved_notifications)
    log("event=enqueue time=#{now() - enqueue_start}")
  end

  defp save_batch(notifications) do
    # Pre-generate Notification IDs so we can build the NotificationSubscription records without
    # having to use `returning` on the Notification insert.
    notifications_with_id = Enum.map(notifications, &%{&1 | id: Ecto.UUID.generate()})

    Repo.transaction(fn ->
      Repo.insert_all(Notification, Enum.map(notifications_with_id, &notification_record/1))

      Repo.insert_all(
        NotificationSubscription,
        Enum.flat_map(notifications_with_id, &notification_subscription_records/1)
      )
    end)

    notifications_with_id
  rescue
    Postgrex.Error ->
      # Fall back on saving this batch individually. Only expected to occur if a user deletes
      # their account while a notification is being sent to them, and in that case filtering out
      # the failed saves (so we don't attempt to send them) is the correct behavior.
      notifications
      |> Stream.map(fn notification ->
        case Notification.save(notification, :sent) do
          {:ok, saved_notification} ->
            saved_notification

          {:error, changeset} ->
            Logger.warn("notification insert failed: #{inspect(changeset)}")
            nil
        end
      end)
      |> Enum.reject(&is_nil/1)
  end

  @notification_fields Notification.__schema__(:fields)

  defp notification_record(%Notification{id: id} = notification) when not is_nil(id) do
    # Converts a Notification to a plain map for use with `insert_all`. Autogenerated fields such
    # as `timestamps` are not populated by `insert_all`, so we add them here.
    notification
    |> Map.take(@notification_fields)
    |> Map.merge(%{
      status: :sent,
      inserted_at: DateTime.utc_now(),
      updated_at: DateTime.utc_now()
    })
  end

  @notification_subscription_fields NotificationSubscription.__schema__(:fields) -- [:id]

  defp notification_subscription_records(%Notification{
         id: notification_id,
         notification_subscriptions: notification_subscriptions
       })
       when not is_nil(notification_id) do
    # Converts a Notification's `notification_subscriptions` association to a list of plain maps
    # for use with `insert_all`. The Notification must have an `id`.
    notification_subscriptions
    |> Enum.map(fn notification_subscription ->
      notification_subscription
      |> Map.take(@notification_subscription_fields)
      |> Map.merge(%{
        notification_id: notification_id,
        inserted_at: DateTime.utc_now(),
        updated_at: DateTime.utc_now()
      })
    end)
  end

  defp log(message) do
    Logger.info("scheduler_log #{message}")
  end

  defp now() do
    System.monotonic_time(:microsecond)
  end
end
