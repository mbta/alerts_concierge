defmodule SendNotifications do
  @user_email "send-notifications-test@example.com"
  @user_phone "555-555-5555"

  @moduledoc """
  Script to create and send a number of fake notifications for testing purposes.

  Usage: mix run send_notifications.exs [options]
      -h, --help      Print this message
      -c, --count N   Create and send N notifications
      -m, --mode M    Use communication mode M (either "email" or "sms")
      -d, --delete    Delete notifications created by this script from the database

  If both `--count` and `--delete` are specified, notifications are sent, then deleted.
  Notifications are sent to either "#{@user_phone}" or "#{@user_email}".
  """

  alias AlertProcessor.Dissemination.MassNotifier
  alias AlertProcessor.Model.{Alert, Subscription, User}
  alias AlertProcessor.{NotificationBuilder, Repo, SendingQueue}

  def run(:help) do
    IO.write(@moduledoc)
  end

  def run({:create, count, mode}) do
    user = create_or_update_user(mode)
    started_at = DateTime.utc_now()

    IO.puts("Creating #{count} notifications...")
    schedule_notifications(user, count)

    IO.puts("Waiting for sending queue to clear...")
    await_notifications_sent()

    duration = DateTime.diff(DateTime.utc_now(), started_at, :millisecond) / 1000
    rate = Float.round(count / duration, 3)
    IO.puts("Done in #{duration} seconds (#{rate} notifications per second)")
  end

  def run(:delete) do
    Ecto.Adapters.SQL.query!(
      AlertProcessor.Repo,
      """
      DELETE FROM notifications
      WHERE user_id IN (SELECT id FROM users WHERE email = '#{@user_email}')
      """,
      [],
      timeout: :infinity
    )
  end

  def run({:create_delete, count, mode}) do
    run({:create, count, mode})
    run(:delete)
  end

  def run(:exit) do
    run(:help)
    System.halt(1)
  end

  defp schedule_notifications(user, count) do
    subscription = get_or_create_subscription(user)

    alert = %Alert{
      id: "notification-test-alert",
      header: "There's a delay",
      service_effect: "Delay",
      last_push_notification: DateTime.utc_now()
    }

    notifications =
      Enum.map(1..count, fn _ ->
        NotificationBuilder.build_notification({user, [subscription]}, alert)
      end)

    MassNotifier.save_and_enqueue(notifications)
  end

  defp await_notifications_sent do
    if SendingQueue.length() > 0 do
      :timer.sleep(100)
      await_notifications_sent()
    end
  end

  defp create_or_update_user(mode) do
    attributes = %{
      email: @user_email,
      phone_number: if(mode == :sms, do: @user_phone, else: nil),
      communication_mode: mode
    }

    case Repo.get_by(User, email: @user_email) do
      nil ->
        {:ok, user} = User.create_account(attributes)
        user

      user ->
        {:ok, user} = User.update_account(user, attributes, user)
        user
    end
  end

  defp get_or_create_subscription(user) do
    case user |> Ecto.assoc(:subscription) |> Repo.one() do
      nil ->
        %Subscription{user_id: user.id, start_time: ~T[00:00:00], end_time: ~T[23:59:59]}
        |> Subscription.create_changeset()
        |> Repo.insert!()

      subscription ->
        subscription
    end
  end
end

# Suppress the large amounts of `info` logs generated by running this script
Logger.configure(level: :warn)

opts =
  OptionParser.parse(
    System.argv(),
    switches: [help: :boolean, count: :integer, mode: :string, delete: :boolean],
    aliases: [h: :help, c: :count, m: :mode, d: :delete]
  )

case opts do
  {[help: true], _, _} -> :help
  {[count: n, mode: m], _, _} -> {:create, n, m}
  {[delete: true], _, _} -> :delete
  {[count: n, mode: m, delete: true], _, _} -> {:create_delete, n, m}
  _ -> :exit
end
|> SendNotifications.run()
